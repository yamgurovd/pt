# Виды тестирования производительности (Performance Testing)

----

Ссылки:

<details> <summary style=" 
          display: inline-block; 
          padding: 4px 12px; 
          background-color: #1976d2; 
          color: white; font-weight: bold; border-radius: 6px; 
          cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.15); 
          transition: background-color 0.3s; font-size: 14px; 
          margin: 0 auto; text-align: center;" 
          onmouseover="this.style.backgroundColor='#1565c0'" 
          onmouseout="this.style.backgroundColor='#1976d2'" > 
          Показать/скрыть картинку </summary> <div style="text-align: center; margin-top: 10px;"> 
          <img src="/2 Введение в профессию QA Performance Engineer/theory.png" alt="Dbeaver" style="display: block; 
          margin: 0 auto; max-width: 90%; height: auto;"> </div> 
</details>

- Performance Testing
- Load Testing
- Stress Testing
- Endurance Testing
- Spike Testing
- Scalability Testing
- Circuit Breaker Design Pattern
- Тестирование производительности (Performance Testing) включает в себя несколько подвидов, каждый из которых
  фокусируется на определённой характеристике системы: скорости отклика, устойчивости, масштабируемости и способности к
  восстановлению. Далее мы рассмотрим ключевые виды такого тестирования.

1. Load Testing (нагрузочное тестирование)

#### Цель:

- Проверка, как система работает под нормальной и увеличенной ожидаемой нагрузкой в течение продолжительного времени.

#### Особенности:

- Эмулируется реалистичная пользовательская активность (например, 100–500 одновременных пользователей).
- Проверяются: производительность, стабильность, скорость отклика, throughput.
- Используется на этапе подготовки к реальному продакшену.

#### Типичные метрики:

- Время отклика (Response Time)
- Пропускная способность (Requests per Second, Throughput)
- Утилизация CPU / памяти / сети
- Количество ошибок

#### Когда использовать:

- Перед релизом или масштабированием
- Для выявления узких мест при ожидаемой нагрузке

2. Stress Testing (стресс-тестирование)

#### Цель:

- Определить максимальную нагрузку, которую система может выдержать до деградации или сбоя. Проверяется поведение за
  пределами нормальных условий.

#### Особенности:

- Нагрузка постепенно или резко увеличивается выше проектной нормы.
- Цель — увидеть, когда и как "ломается" система, и как она восстанавливается после сбоя.
- Тестируется устойчивость и деградация, а не стабильная работа.

#### Нюансы:

- Может привести к серьёзным сбоям, поэтому не проводится в продакшене.
- Важно отслеживать, какие компоненты первыми выходят из строя.

#### Когда использовать:

- При оценке пределов масштабируемости
- При подготовке к резким пиковым нагрузкам (распродажи, маркетинговые кампании)

3. Soak Testing / Endurance Testing (тестирование выносливости)
   ####Цель:

- Проверить стабильность системы при продолжительной нагрузке (несколько часов или даже дней) с целью выявления утечек
  ресурсов и накопительных эффектов.

#### Особенности:

- Нагрузка может быть на уровне Load Testing, но важно время: часы, сутки.
- Ищутся памятные утечки, утечка соединений, ухудшение времени отклика со временем.
- Выявляются проблемы, которые не видны при коротком тестировании.

#### Когда использовать:

- В критических системах с длительной работой (банкинг, телеком)
- После обновлений, которые могут повлиять на сборку мусора, кеширование и пр.


4. Spike Testing (тестирование всплесков)

#### Цель:

- Оценить реакцию системы на резкий, кратковременный всплеск нагрузки.

#### Особенности:

- В отличие от Stress Testing, нагрузка скачет внезапно и резко, а не нарастает.
- Имитируется ситуация, например, когда внезапно заходит 10 000 пользователей за 1 секунду.
- Проверяется, как система "переживает" пик и восстанавливается.

#### Когда использовать:

- Для оценки реакции на DDoS, флешмобы, баги в клиентском ПО
- Для тестирования автоскейлинга и кэширования


5. Scalability Testing (тестирование масштабируемости)

#### Цель:

- Проверить, насколько хорошо система масштабируется при увеличении:

- числа пользователей,
- объёма данных,
- количества узлов и ресурсов (CPU, памяти и т.д.)

#### Особенности:

- Может проводиться как в вертикальном (увеличение ресурсов), так и в горизонтальном масштабе (добавление инстансов).
- Анализируется эффективность масштабирования: линейное, сублинейное или деградирующее.

#### Когда использовать:

- При выборе между горизонтальным и вертикальным масштабированием
- При тестировании облачных или распределённых архитектур

6. Failover / Resilience Testing (тестирование отказоустойчивости)

#### Цель:

- Оценить, как система реагирует на сбой компонентов (сервисов, БД, сети, дисков), и способна ли она восстановиться.

#### Особенности:

- Имитируются реальные сбои: отключение узла, отказ БД, network partition, и т.д.
- Часто сочетается с Chaos Testing.
- Проверяются механизмы репликации, автоматического переключения, circuit breaker'ы и пр.

#### Когда использовать:

- При построении отказоустойчивых систем
- Для валидации резервирования и механизмов восстановления
- Circuit Breaker
- Circuit Breaker (в контексте распределённых систем и отказоустойчивости) — это паттерн устойчивости, который
  предотвращает повторяющиеся попытки обращения к зависимому (часто внешнему) компоненту, если он уже не отвечает или
  работает с ошибками. Другими словами это программный механизм, который временно блокирует вызовы к ресурсу (например,
  микросервису или базе данных), если обнаружено, что он находится в ошибочном или нестабильном состоянии. Это помогает
  избежать избыточной нагрузки на зависимость и позволяет системе восстанавливаться более эффективно.

#### Circuit Breaker имеет три состояния:

##### Closed (закрыт):

- Всё работает нормально.
- Запросы проходят к целевому компоненту.
- При ошибках считает количество/частоту неудач.

##### Open (открыт):

- Когда число неудач превышает порог — "перегорает".
- Запросы не отправляются, а сразу получают ошибку.
  Даёт целевому компоненту "время на восстановление".

##### Half-Open (полуоткрыт):

- Через некоторое время позволяет отправить ограниченное количество пробных запросов.
- Если они успешны — возвращается в Closed.
- Если снова ошибка — возвращается в Open.

##### Зачем нужен:

- Защищает систему от каскадных сбоев.
- Улучшает восстанавливаемость и устойчивость.
- Избегает перегрузки зависимого сервиса в момент, когда он уже не работает.

##### Примеры применения:

- Между микросервисами, где один сервис зависит от другого.
- При работе с нестабильной внешней API.
- В связке с retry и fallback логикой.

7. Chaos Testing (хаос-тестирование)

##### Цель:

- Преднамеренно вносить хаос и неопределённость в систему, чтобы проверить её устойчивость и надёжность в условиях
  неожиданных сбоев.

##### Особенности:

- Выключение случайных сервисов, сетевых подключений, подмена данных.
- Нестабильность создаётся преднамеренно, часто в продакшене.
- Используется инструментами типа Chaos Monkey, Gremlin.

##### Нюансы:

- Требует зрелой инфраструктуры, мониторинга и автоматического восстановления.
- Очень мощный инструмент, но опасен без должного контроля.

###### Сводная таблица сравнения:

- Вид теста Цель Нагрузка Продолжительность Пример метрик
- Load Testing Проверить стабильность В норме Средняя Время отклика, ошибки
- Stress Testing Найти пределы Сверх нормы Кратковременная Точка отказа, деградация
- Soak Testing Найти утечки, дрейф В норме Долгая Утечки памяти, рост latency
- Spike Testing Проверить на всплески Резкие пики Кратковременная Пиковое поведение, отклик
- Scalability Testing Проверить масштабируемость Растущая Любая Throughput на ресурс
- Resilience Testing Проверить восстановление Любая По сценарию Восстановление, ошибки
  -Chaos Testing Проверить устойчивость к сбоям Нестабильная Любая Выживаемость, самовосстановление